const bcrypt = require('bcryptjs');
const crypto = require('crypto'); 
const User = require('../models/user_model'); 
const nodemailer = require('nodemailer');
const { validationResult } = require('express-validator'); 

const transport = nodemailer.createTransport({
  host: "smtp.mailtrap.io",
  port: 2525,
  auth: {
    user: "generated by Mailtrap",
    pass: "generated by Mailtrap"
  }
});

const getSignup = (req, res, next) => {
  if (req.session.isLoggedIn) {
    res.redirect('/');
  } else {
    let message = req.flash('errorMsgAuth');
    if (message.length <= 0){
      message = null;
    }
    res.render('auth/signup', { docTitle: 'signup', path: '/signup', errorMessage: message,
    oldInputs: {email: "", password: ""}, typeErrors: []});
  }
}

const postSignup = (req, res, next) => {
  const uName = req.body.name;
  const uEmail = req.body.email;
  const uPassword = req.body.password;
  const errors = validationResult(req); 

  if(!errors.isEmpty()) {
    const typeErrors = errors.array().map(e => e.param);
    return res.status(422).render('auth/signup', { docTitle: 'SignUp', path: '/signup', oldInputs: {email: uEmail, password: uPassword, name: uName}, 
    errorMessage: 'Please enter valid inputs.', typeErrors: typeErrors, validationErrors: errors.array()});
  }

    bcrypt.hash(uPassword, 12) 
    .then(hashedPassword => {
      const user = new User({uName, uEmail, uPassword: hashedPassword, cart: {items: []}})
      return user.save()
    })
    .then(() => {
      res.redirect('/login');
      transport.sendMail( 
        {
          from: ' EMAIL ',
          to: uEmail,
          subject: 'Sending Email using Node.js',
          text: 'Will it work?',
          html: '<h1>You successfully signed up!</h1>'
        }, 
        function(error, info){
          if (error) {
            return next(error);
          } else {
            console.log('Email sent: ' + info.messageId);
          }
        }
      );
    })
    .catch(err => next(err))
}

const getLogin = (req, res, next) => {
  if (req.session.isLoggedIn) {
    res.redirect('/');
  } else {
    let message = req.flash('errorMsgAuth');
    if (message.length <= 0){
      message = null;
    }
    res.render('auth/login', { docTitle: 'Login', path: '/login', errorMessage: message,
    oldInputs: {email: "", password: ""}, typeErrors: []});
  }
}; 

const postLogin = (req, res, next) => { 
  const uEmail = req.body.email;
  const uPassword = req.body.password;
  const errors = validationResult(req); 

  if(!errors.isEmpty()) {
    const typeErrors = errors.array().map(e => e.param);
    return res.status(422).render('auth/login', { docTitle: 'Login', path: '/login', 
    errorMessage: 'Please enter valid inputs.', typeErrors: typeErrors, 
    oldInputs: {email: uEmail, password: uPassword}});
  }

  User.findOne({uEmail: uEmail}).then(user => {
    if (!user) {
      return res.status(422).render('auth/login', { docTitle: 'Login', path: '/login', 
      errorMessage: 'Email does not have an account.', typeErrors: [], oldInputs: {email: uEmail}})
    }
    bcrypt.compare(uPassword, user.uPassword)
    .then((result) => {
      if (!result) {
        return res.status(422).render('auth/login', { docTitle: 'Login', path: '/login', 
        errorMessage: 'Invalid password.', typeErrors: [], oldInputs: {email: uEmail}}) 
      }
      req.session.isLoggedIn = true; 
      req.session.user = user;
      req.session.save(err => { 
      if(err) {
        return next(err);
      }
      return res.redirect('/');
      }) 
    })
    .catch(err => { 
      console.log(err);
      res.redirect('/login');
    })
  }).catch(err => next(err));
}; 

const postLogout = (req, res, next) => {
  req.session.destroy(err => { 
    if(err){
      return next(err);
    }
    res.redirect('/');
  });
}

const getReset = (req, res, next) => {
  let message = req.flash('errorMsgAuth');
  if (message.length <= 0){
    message = null;
  }
  res.render('auth/reset', { docTitle: 'Reset Password', path: '/reset', errorMessage: message})
}

const postReset = (req, res, next) => {
  const errors = validationResult(req);

  if(!errors.isEmpty()) {
    return res.status(422).render('auth/reset', { docTitle: 'Reset Password', path: '/reset', 
    errorMessage: errors.array()[0].msg});
  }

  crypto.randomBytes(32, (err, buffer) => {
    if (err) {
      console.log(err);
      return res.redirect('/reset');
    }
    const token = buffer.toString('hex'); 
    User.findOne({uEmail: req.body.email}).then((user) => {
      if (!user) {
        req.flash('errorMsgAuth', 'No account with this email.');
        return res.redirect('/reset');
      }
      user.resetToken = token,
      user.resetTokenExpiration = Date.now() + 3600000;
      return user.save()
    })
    .then(() => {
      res.redirect('/login');
      transport.sendMail({
        to: req.body.email,
        from: ' EMAIL ',
        subject: 'Password reset',
        html: `
          <p>You requested a password reset</p>
          <p>Click this <a href="http://localhost:3000/new-password/${token}">link</a> to set a new password.</p>
        `
      });
    })
    .catch(err => next(err))
  })
}

const getNewPassword = (req, res, next) => {
  const token = req.params.token;
  const errors = validationResult(req);

  User.findOne({resetToken: token, resetTokenExpiration: {$gt: Date.now()}})
  .then((user) => {
    if(!user) {
      req.flash('errorMsgAuth', 'Link is invalid or expirated.');
      return res.redirect('/reset');
    }
    let message = req.flash('errorMsgAuth');
    if (message.length <= 0){
      message = null;
    }
    res.render('auth/new-password', { docTitle: 'Update Password', path: '/new-password', 
    errorMessage: errors.isEmpty() ? message : errors.array()[0].msg, passwordToken: token, 
    userId: user._id.toString() });
  }).catch(err => next(err));
}

const postNewPassword = (req, res, next) => {
  const newPassword = req.body.password;
  const passwordToken = req.body.passwordToken;
  const errors = validationResult(req);

  if(!errors.isEmpty()) {
    return res.status(422).redirect('/new-password');
  }

  User.findOne({_id: req.body.userId, resetToken: passwordToken, resetTokenExpiration: {$gt: Date.now()}})
  .then(user => {
    if(!user) {
      req.flash('errorMsgAuth', 'Link is invalid or expirated.');
      return res.redirect('/reset');
    }
    bcrypt.hash(newPassword, 12).then(hashedPassword => {
      user.uPassword = hashedPassword;
      user.resetToken = undefined;
      user.resetTokenExpiration = undefined;
      return user.save()
    })
  }).then(() => {
    res.redirect('/login');
  }).catch(err => next(err));
}
 
module.exports = {getLogin, postLogin, postLogout, getSignup, postSignup, getReset, postReset,
  getNewPassword, postNewPassword}